<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"></head><body><div class="container"><table class="table table-hover"><thead><tr class=""><th scope="col" class="" id="cell-0">P2</th><th scope="col" class="" id="cell-1"></th><th scope="col" class="" id="cell-2"></th><th scope="col" class="" id="cell-3"></th></tr></thead><tbody><tr class=""><th scope="col" class="" id="cell-4">Kriterium</th><th scope="col" class="" id="cell-5">Möglich</th><th scope="col" class="" id="cell-6">Erzielt</th><th scope="col" class="" id="cell-7">Kommentar</th></tr><tr class=""><th scope="col" class="" id="cell-8">H1 | Lesen</th><th scope="col" class="" id="cell-9">[0, 4]</th><th scope="col" class="" id="cell-10">[0, 4]</th><th scope="col" class="" id="cell-11"></th></tr><tr class=""><td class="" id="cell-12"><span class="badge">1</span> Die Methode <code>read</code> funktioniert korrekt, wenn der Wurzelknoten keine Kinder hat.</td><td class="" id="cell-13">[0, 1]</td><td class="table-warning" id="cell-14">[0, 1]</td><td class="" id="cell-15">Not graded by public grader</td></tr><tr class=""><td class="" id="cell-16"><span class="badge">2</span> Die Methode <code>read</code> funktioniert korrekt, wenn nur alle Intervalle komplett gelesen werden.</td><td class="" id="cell-17">[0, 1]</td><td class="table-warning" id="cell-18">[0, 1]</td><td class="" id="cell-19">Not graded by public grader</td></tr><tr class=""><td class="" id="cell-20"><span class="badge">3</span> Die Methode <code>read</code> funktioniert korrekt, wenn das Startintervall nur zum Teil gelesen wird.</td><td class="" id="cell-21">[0, 1]</td><td class="table-warning" id="cell-22">[0, 1]</td><td class="" id="cell-23">Not graded by public grader</td></tr><tr class=""><td class="" id="cell-24"><span class="badge">4</span> Die Methode <code>read</code> funktioniert korrekt, wenn das Start- und Endintervall nur zum Teil gelesen wird.</td><td class="" id="cell-25">[0, 1]</td><td class="table-warning" id="cell-26">[0, 1]</td><td class="" id="cell-27">Not graded by public grader</td></tr><tr class=""><th scope="col" class="" id="cell-28">H2 | Einfügen</th><th scope="col" class="" id="cell-29">[0, 11]</th><th scope="col" class="" id="cell-30">[0, 3]</th><th scope="col" class="" id="cell-31"></th></tr><tr class=""><th scope="col" class="" id="cell-32">H2 a) | Split</th><th scope="col" class="" id="cell-33">[0, 4]</th><th scope="col" class="" id="cell-34">0</th><th scope="col" class="" id="cell-35"></th></tr><tr class=""><td class="" id="cell-36"><span class="badge">5</span> Die Methode <code>split</code> splittet den Knoten in normalen Fällen korrekt.</td><td class="" id="cell-37">[0, 1]</td><td class="table-danger" id="cell-38">0</td><td class="" id="cell-39"><nobr><i>The tree is not correct. The size of the node {{"A","B","C","D","E"},"F",{"G","H","I","J","K"}} is not correct. Expected Node: {{"A","B","C","D","E"},"F",{"G","H"},"I",{"J","K"}}</i></nobr><wbr><nobr><i> @ BtrfsFile.split()</i></nobr> {<div class="pl-4">original Tree = {{"A","B","C","D","E"},"F",{"G","H","I","J","K"}},<br>degree = 3,<br>parentIndex = 1,<br>childIndex = 1,<br>expected tree = {{"A","B","C","D","E"},"F",{"G","H"},"I",{"J","K"}},<br>actual tree = {{"A","B","C","D","E"},"F",{"G","H","I","J","K"}}</div>}<br><nobr><i>expected</i> &lt;2&gt;</nobr><br><nobr><i>actual</i> &lt;1&gt;</nobr><br><br><br>there are 2 more failing tests</td></tr><tr class=""><td class="" id="cell-40"><span class="badge">6</span> Die Methode <code>split</code> aktualisiert die Werte in der übergebenen IndexedNodeLinkedList korrekt.</td><td class="" id="cell-41">[0, 1]</td><td class="table-danger" id="cell-42">0</td><td class="" id="cell-43"><nobr><i>indexedNode.parent.index is not correct.</i></nobr><wbr><nobr><i> @ BtrfsFile.split()</i></nobr> {<div class="pl-4">original Tree = {{"A","B","C","D","E"},"F",{"G","H","I","J","K"}},<br>degree = 3,<br>parentIndex = 1,<br>childIndex = 3,<br>expectedParentIndex = 2,<br>expectedChildIndex = 0,<br>actual tree = {{"A","B","C","D","E"},"F",{"G","H","I","J","K"}}</div>}<br><nobr><i>expected</i> &lt;2&gt;</nobr><br><nobr><i>actual</i> &lt;1&gt;</nobr><br><br><br>there is 1 more failing test</td></tr><tr class=""><td class="" id="cell-44"><span class="badge">7</span> Die Methode <code>split</code> funktioniert korrekt, wenn der Wurzelknoten gesplittet wird.</td><td class="" id="cell-45">[0, 1]</td><td class="table-danger" id="cell-46">0</td><td class="" id="cell-47"><nobr><i>The tree is not correct. The size of the node {"A","B","C","D","E"} is not correct. Expected Node: {{"A","B"},"C",{"D","E"}}</i></nobr><wbr><nobr><i> @ BtrfsFile.split()</i></nobr> {<div class="pl-4">original Tree = {"A","B","C","D","E"},<br>degree = 3,<br>index = 0,<br>expectedParentIndex = 0,<br>expectedChildIndex = 0,<br>expected tree = {{"A","B"},"C",{"D","E"}},<br>actual tree = {"A","B","C","D","E"}</div>}<br><nobr><i>expected</i> &lt;1&gt;</nobr><br><nobr><i>actual</i> &lt;5&gt;</nobr><br><br><br>there are 6 more failing tests</td></tr><tr class=""><td class="" id="cell-48"><span class="badge">8</span> Die Methode <code>split</code> funktioniert zusätzlich korrekt, wenn rekursive mehrere Knoten gesplittet werden müssen.</td><td class="" id="cell-49">[0, 1]</td><td class="table-danger" id="cell-50">0</td><td class="" id="cell-51"><nobr><i>The tree is not correct. The size of the node {{"A","B","C","D","E"},"F",{"G","H","I","J","K"}} is not correct. Expected Node: {{"A","B","C","D","E"},"F",{"G","H"},"I",{"J","K"}}</i></nobr><wbr><nobr><i> @ BtrfsFile.split()</i></nobr> {<div class="pl-4">original Tree = {{"A","B","C","D","E"},"F",{"G","H","I","J","K"}},<br>degree = 3,<br>parentIndex = 1,<br>childIndex = 1,<br>expected tree = {{"A","B","C","D","E"},"F",{"G","H"},"I",{"J","K"}},<br>actual tree = {{"A","B","C","D","E"},"F",{"G","H","I","J","K"}}</div>}<br><nobr><i>expected</i> &lt;2&gt;</nobr><br><nobr><i>actual</i> &lt;1&gt;</nobr><br><br><br>there are 2 more failing tests</td></tr><tr class=""><th scope="col" class="" id="cell-52">H2 b) | findInsertionPosition</th><th scope="col" class="" id="cell-53">[0, 4]</th><th scope="col" class="" id="cell-54">0</th><th scope="col" class="" id="cell-55"></th></tr><tr class=""><td class="" id="cell-56"><span class="badge">9</span> Die Methode <code>findInsertionPosition</code> funktioniert korrekt, wenn der WurzelKnoten keine Kinder hat und kein Intervall aufgeteilt werden muss.</td><td class="" id="cell-57">[0, 1]</td><td class="table-danger" id="cell-58">0</td><td class="" id="cell-59"><nobr><i>findInsertionPosition() should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.findInsertionPosition()</i></nobr> {<div class="pl-4">tree = {"A","B","C","D"},<br>degree = 3,<br>start = 0,<br>InsertionSize = 20,<br>expectedIndices = [0],<br>expected tree = {"A","B","C","D"}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.findInsertionPosition(BtrfsFile.java:206)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.FindInsertionPositionTests.callFindInsertionPosition(FindInsertionPositionTests.java:145)<br>	p2.FindInsertionPositionTests.lambda$testFindInsertionPosition$0(FindInsertionPositionTests.java:99)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfObject.run(BasicTestOfObject.java:31)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.callObject(Assertions2.java:274)<br>	p2.FindInsertionPositionTests.testFindInsertionPosition(FindInsertionPositionTests.java:99)<br>...<br></div></div><br><br>there are 4 more failing tests</td></tr><tr class=""><td class="" id="cell-60"><span class="badge">10</span> Die Methode <code>findInsertionPosition</code> funktioniert zusätzlich korrekt, wenn der Wurzelknoten Kinder hat und kein Intervall aufgeteilt werden muss.</td><td class="" id="cell-61">[0, 1]</td><td class="table-danger" id="cell-62">0</td><td class="" id="cell-63"><nobr><i>findInsertionPosition() should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.findInsertionPosition()</i></nobr> {<div class="pl-4">tree = {"A","B","C","D"},<br>degree = 3,<br>start = 0,<br>InsertionSize = 20,<br>expectedIndices = [0],<br>expected tree = {"A","B","C","D"}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.findInsertionPosition(BtrfsFile.java:206)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.FindInsertionPositionTests.callFindInsertionPosition(FindInsertionPositionTests.java:145)<br>	p2.FindInsertionPositionTests.lambda$testFindInsertionPosition$0(FindInsertionPositionTests.java:99)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfObject.run(BasicTestOfObject.java:31)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.callObject(Assertions2.java:274)<br>	p2.FindInsertionPositionTests.testFindInsertionPosition(FindInsertionPositionTests.java:99)<br>...<br></div></div><br><br>there are 4 more failing tests</td></tr><tr class=""><td class="" id="cell-64"><span class="badge">11</span> Die Methode <code>findInsertionPosition</code> funktioniert zusätzlich korrekt, wenn Intervalle aufgeteilt werden müssen, aber der Blattknoten nicht voll ist.</td><td class="" id="cell-65">[0, 1]</td><td class="table-danger" id="cell-66">0</td><td class="" id="cell-67"><nobr><i>findInsertionPosition() should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.findInsertionPosition()</i></nobr> {<div class="pl-4">tree = {"A","B","C","D"},<br>degree = 3,<br>start = 0,<br>InsertionSize = 20,<br>expectedIndices = [0],<br>expected tree = {"A","B","C","D"}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.findInsertionPosition(BtrfsFile.java:206)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.FindInsertionPositionTests.callFindInsertionPosition(FindInsertionPositionTests.java:145)<br>	p2.FindInsertionPositionTests.lambda$testFindInsertionPosition$0(FindInsertionPositionTests.java:99)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfObject.run(BasicTestOfObject.java:31)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.callObject(Assertions2.java:274)<br>	p2.FindInsertionPositionTests.testFindInsertionPosition(FindInsertionPositionTests.java:99)<br>...<br></div></div><br><br>there are 4 more failing tests</td></tr><tr class=""><td class="" id="cell-68"><span class="badge">12</span> Die Methode <code>findInsertionPosition</code> funktioniert zusätzlich korrekt, wenn Intervalle aufgeteilt werden müssen und der Blattknoten voll ist.</td><td class="" id="cell-69">[0, 1]</td><td class="table-danger" id="cell-70">0</td><td class="" id="cell-71"><nobr><i>findInsertionPosition() should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.findInsertionPosition()</i></nobr> {<div class="pl-4">tree = {"A","B","C","D"},<br>degree = 3,<br>start = 0,<br>InsertionSize = 20,<br>expectedIndices = [0],<br>expected tree = {"A","B","C","D"}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.findInsertionPosition(BtrfsFile.java:206)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.FindInsertionPositionTests.callFindInsertionPosition(FindInsertionPositionTests.java:145)<br>	p2.FindInsertionPositionTests.lambda$testFindInsertionPosition$0(FindInsertionPositionTests.java:99)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfObject.run(BasicTestOfObject.java:31)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.callObject(Assertions2.java:274)<br>	p2.FindInsertionPositionTests.testFindInsertionPosition(FindInsertionPositionTests.java:99)<br>...<br></div></div><br><br>there are 4 more failing tests</td></tr><tr class=""><th scope="col" class="" id="cell-72">H2 c) | insert</th><th scope="col" class="" id="cell-73">[0, 3]</th><th scope="col" class="" id="cell-74">[0, 3]</th><th scope="col" class="" id="cell-75"></th></tr><tr class=""><td class="" id="cell-76"><span class="badge">13</span> Die Methode <code>insert</code> funktioniert korrekt, wenn alle Intervalle in den momentanen Knoten passen.</td><td class="" id="cell-77">[0, 1]</td><td class="table-warning" id="cell-78">[0, 1]</td><td class="" id="cell-79">Not graded by public grader</td></tr><tr class=""><td class="" id="cell-80"><span class="badge">14</span> Die Methode <code>insert</code> funktioniert korrekt, wenn nicht alle Intervalle in den momentanen Knoten passen und nach dem Splitten aber weiterhin in den selben Knoten eingefügt wird.</td><td class="" id="cell-81">[0, 1]</td><td class="table-warning" id="cell-82">[0, 1]</td><td class="" id="cell-83">Not graded by public grader</td></tr><tr class=""><td class="" id="cell-84"><span class="badge">15</span> Die Methode <code>insert</code> funktioniert korrekt, wenn nicht alle Intervalle in den momentanen Knoten passen und nach dem Splitten in einen anderen Knoten eingefügt wird.</td><td class="" id="cell-85">[0, 1]</td><td class="table-warning" id="cell-86">[0, 1]</td><td class="" id="cell-87">Not graded by public grader</td></tr><tr class=""><th scope="col" class="" id="cell-88">H3 | Löschen</th><th scope="col" class="" id="cell-89">[0, 15]</th><th scope="col" class="" id="cell-90">4</th><th scope="col" class="" id="cell-91"></th></tr><tr class=""><th scope="col" class="" id="cell-92">H3 a) | Rotieren</th><th scope="col" class="" id="cell-93">[0, 4]</th><th scope="col" class="" id="cell-94">4</th><th scope="col" class="" id="cell-95"></th></tr><tr class=""><td class="" id="cell-96"><span class="badge">16</span> Nach dem Aufrufen der Methode <code>rotateFromRightChild</code> ist der Knoten, in welchen hineinrotiert wird, korrekt und an der richtigen Position.</td><td class="" id="cell-97">[0, 1]</td><td class="table-success" id="cell-98">1</td><td class="" id="cell-99"></td></tr><tr class=""><td class="" id="cell-100"><span class="badge">17</span> Nach dem Aufrufen der Methode <code>rotateFromRightChild</code> ist der rechte Knoten korrekt und an der richtigen Position.</td><td class="" id="cell-101">[0, 1]</td><td class="table-success" id="cell-102">1</td><td class="" id="cell-103"></td></tr><tr class=""><td class="" id="cell-104"><span class="badge">18</span> Nach dem Aufrufen der Methode <code>rotateFromRightChild</code> ist der gesamte Baum korrekt.</td><td class="" id="cell-105">[0, 1]</td><td class="table-success" id="cell-106">1</td><td class="" id="cell-107"></td></tr><tr class=""><td class="" id="cell-108"><span class="badge">19</span> Nach dem Aufrufen der Methode <code>rotateFromLeftChild</code> ist der gesamte Baum korrekt.</td><td class="" id="cell-109">[0, 1]</td><td class="table-success" id="cell-110">1</td><td class="" id="cell-111"></td></tr><tr class=""><th scope="col" class="" id="cell-112">H3 b) | Mergen</th><th scope="col" class="" id="cell-113">[0, 3]</th><th scope="col" class="" id="cell-114">0</th><th scope="col" class="" id="cell-115"></th></tr><tr class=""><td class="" id="cell-116"><span class="badge">20</span> Nach dem Aufrufen der Methode <code>mergeWithRightChild</code> ist der Kindknoten korrekt und an der korrekten Position.</td><td class="" id="cell-117">[0, 1]</td><td class="table-danger" id="cell-118">0</td><td class="" id="cell-119"><nobr><i>The tree is not correct. The size of the node {"D","E"} is not correct. Expected Node: {"D","E","F","G","H"}</i></nobr><wbr><nobr><i> @ BtrfsFile.mergeWith*Sibling()</i></nobr> {<div class="pl-4">tree = {{"A","B"},"C",{"D","E"},"F",{"G","H"}},<br>degree = 3,<br>parentIndex = 1,<br>childIndex = 1,<br>expectedParentIndex = 1,<br>expectedChildIndex = 1,<br>expected tree = {{"A","B"},"C",{"D","E","F","G","H"}},<br>actual tree = {{"A","B"},"C",{"D","E"},"F",{"G","H"}}</div>}<br><nobr><i>expected</i> &lt;5&gt;</nobr><br><nobr><i>actual</i> &lt;2&gt;</nobr><br><br><br>there are 5 more failing tests</td></tr><tr class=""><td class="" id="cell-120"><span class="badge">21</span> Nach dem Aufrufen der Methode <code>mergeWithRightChild</code> ist der gesamte Baum korrekt.</td><td class="" id="cell-121">[0, 1]</td><td class="table-danger" id="cell-122">0</td><td class="" id="cell-123"><nobr><i>The tree is not correct. The size of the node {{"A","B"},"C",{"D","E"},"F",{"G","H"}} is not correct. Expected Node: {{"A","B"},"C",{"D","E","F","G","H"}}</i></nobr><wbr><nobr><i> @ BtrfsFile.mergeWith*Sibling()</i></nobr> {<div class="pl-4">tree = {{"A","B"},"C",{"D","E"},"F",{"G","H"}},<br>degree = 3,<br>parentIndex = 1,<br>childIndex = 1,<br>expectedParentIndex = 1,<br>expectedChildIndex = 1,<br>expected tree = {{"A","B"},"C",{"D","E","F","G","H"}},<br>actual tree = {{"A","B"},"C",{"D","E"},"F",{"G","H"}}</div>}<br><nobr><i>expected</i> &lt;1&gt;</nobr><br><nobr><i>actual</i> &lt;2&gt;</nobr><br><br><br>there are 5 more failing tests</td></tr><tr class=""><td class="" id="cell-124"><span class="badge">22</span> Nach dem Aufrufen der Methode <code>mergeWithLeftChild</code> ist der gesamte Baum korrekt.</td><td class="" id="cell-125">[0, 1]</td><td class="table-danger" id="cell-126">0</td><td class="" id="cell-127"><nobr><i>mergeWithLeftSibling() should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.mergeWith*Sibling()</i></nobr> {<div class="pl-4">tree = {{"A","B"},"C",{"D","E"},"F",{"G","H"}},<br>degree = 3,<br>parentIndex = 2,<br>childIndex = 1,<br>expectedParentIndex = 1,<br>expectedChildIndex = 4,<br>expected tree = {{"A","B"},"C",{"D","E","F","G","H"}}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.mergeWithLeftSibling(BtrfsFile.java:527)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.MergeTests.callMergeLeft(MergeTests.java:148)<br>	p2.MergeTests.lambda$testMerge$3(MergeTests.java:100)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfCall.run(BasicTestOfCall.java:21)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.call(Assertions2.java:270)<br>	p2.MergeTests.testMerge(MergeTests.java:100)<br>...<br></div></div><br><br>there are 5 more failing tests</td></tr><tr class=""><th scope="col" class="" id="cell-128">H3 c) | ensureSize</th><th scope="col" class="" id="cell-129">[0, 4]</th><th scope="col" class="" id="cell-130">0</th><th scope="col" class="" id="cell-131"></th></tr><tr class=""><td class="" id="cell-132"><span class="badge">23</span> Die Methode <code>ensureSize</code> funktioniert korrekt, wenn rotateFromRightChild aufgerufen werden muss.</td><td class="" id="cell-133">[0, 1]</td><td class="table-danger" id="cell-134">0</td><td class="" id="cell-135"><nobr><i>ensureSize() should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.ensureSize()</i></nobr> {<div class="pl-4">tree = {{"A","B"},"C",{"D","E","F"}},<br>degree = 3,<br>parentIndex = 0,<br>childIndex = 0,<br>expectedParentIndex = 0,<br>expectedChildIndex1 = 0,<br>expected = {{"A","B","C"},"D",{"E","F"}}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.ensureSize(BtrfsFile.java:516)<br>	jdk.internal.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.EnsureSizeTests.callEnsureSize(EnsureSizeTests.java:222)<br>	p2.EnsureSizeTests.lambda$testEnsureSize$0(EnsureSizeTests.java:162)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfCall.run(BasicTestOfCall.java:21)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.call(Assertions2.java:270)<br>	p2.EnsureSizeTests.testEnsureSize(EnsureSizeTests.java:162)<br>	p2.EnsureSizeTests.testRotateRight(EnsureSizeTests.java:48)<br>...<br></div></div><br><br>there are 2 more failing tests</td></tr><tr class=""><td class="" id="cell-136"><span class="badge">24</span> Die Methode <code>ensureSize</code> funktioniert korrekt, wenn rotateFromLeftChild aufgerufen werden muss, oder beide aufgerufen werden können.</td><td class="" id="cell-137">[0, 1]</td><td class="table-danger" id="cell-138">0</td><td class="" id="cell-139"><nobr><i>ensureSize() should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.ensureSize()</i></nobr> {<div class="pl-4">tree = {{"A","B","C","D"},"E",{"F","G"}},<br>degree = 3,<br>parentIndex = 1,<br>childIndex = 0,<br>expectedParentIndex = 1,<br>expectedChildIndex1 = 1,<br>expected = {{"A","B","C"},"D",{"E","F","G"}}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.ensureSize(BtrfsFile.java:516)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.EnsureSizeTests.callEnsureSize(EnsureSizeTests.java:222)<br>	p2.EnsureSizeTests.lambda$testEnsureSize$0(EnsureSizeTests.java:162)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfCall.run(BasicTestOfCall.java:21)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.call(Assertions2.java:270)<br>	p2.EnsureSizeTests.testEnsureSize(EnsureSizeTests.java:162)<br>...<br></div></div><br><br>there are 3 more failing tests</td></tr><tr class=""><td class="" id="cell-140"><span class="badge">25</span> Die Methode <code>ensureSize</code> funktioniert korrekt, wenn mergeWithRightChild aufgerufen werden muss.</td><td class="" id="cell-141">[0, 1]</td><td class="table-danger" id="cell-142">0</td><td class="" id="cell-143"><nobr><i>ensureSize() should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.ensureSize()</i></nobr> {<div class="pl-4">tree = {{"A","B"},"C",{"D","E"}},<br>degree = 3,<br>parentIndex = 0,<br>childIndex = 1,<br>expectedParentIndex = 0,<br>expectedChildIndex1 = 1,<br>expected = {"A","B","C","D","E"}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.ensureSize(BtrfsFile.java:516)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.EnsureSizeTests.callEnsureSize(EnsureSizeTests.java:222)<br>	p2.EnsureSizeTests.lambda$testEnsureSize$0(EnsureSizeTests.java:162)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfCall.run(BasicTestOfCall.java:21)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.call(Assertions2.java:270)<br>	p2.EnsureSizeTests.testEnsureSize(EnsureSizeTests.java:162)<br>...<br></div></div><br><br>there is 1 more failing test</td></tr><tr class=""><td class="" id="cell-144"><span class="badge">26</span> Die Methode <code>ensureSize</code> funktioniert korrekt, wenn mergeWithLeftChild aufgerufen werden kann, beide Methoden aufgerufen werden können, oder gar keine Methode aufgerufen werden muss.</td><td class="" id="cell-145">[0, 1]</td><td class="table-danger" id="cell-146">0</td><td class="" id="cell-147"><nobr><i>ensureSize() should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.ensureSize()</i></nobr> {<div class="pl-4">tree = {{"A","B"},"C",{"D","E"},"F",{"G","H"}},<br>degree = 3,<br>parentIndex = 2,<br>childIndex = 0,<br>expectedParentIndex = 1,<br>expectedChildIndex1 = 3,<br>expected = {{"A","B"},"C",{"D","E","F","G","H"}}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.ensureSize(BtrfsFile.java:516)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.EnsureSizeTests.callEnsureSize(EnsureSizeTests.java:222)<br>	p2.EnsureSizeTests.lambda$testEnsureSize$0(EnsureSizeTests.java:162)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfCall.run(BasicTestOfCall.java:21)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.call(Assertions2.java:270)<br>	p2.EnsureSizeTests.testEnsureSize(EnsureSizeTests.java:162)<br>...<br></div></div><br><br>there is 1 more failing test</td></tr><tr class=""><th scope="col" class="" id="cell-148">H3 d) | removeRightMostKey und removeLeftMostKey</th><th scope="col" class="" id="cell-149">[0, 4]</th><th scope="col" class="" id="cell-150">0</th><th scope="col" class="" id="cell-151"></th></tr><tr class=""><td class="" id="cell-152"><span class="badge">27</span> Die Methode <code>removeRightMostKey</code> funktioniert korrekt, wenn der Knoten ein Blattknoten ist und mehr als die Mindestanzahl an Schlüsselwerten besitzt.</td><td class="" id="cell-153">[0, 1]</td><td class="table-danger" id="cell-154">0</td><td class="" id="cell-155"><nobr><i>removeRightMostKey should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.rotateFromRightSibling()</i></nobr> {<div class="pl-4">tree = {"A","B","C","D","E"},<br>degree = 3,<br>expected tree = {"A","B","C","D"}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.removeRightMostKey(BtrfsFile.java:490)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.RemoveLRMostKeyTests.callRemoveRightMostKey(RemoveLRMostKeyTests.java:111)<br>	p2.RemoveLRMostKeyTests.lambda$testRemoveLRMostKey$0(RemoveLRMostKeyTests.java:86)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfObject.run(BasicTestOfObject.java:31)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.callObject(Assertions2.java:274)<br>	p2.RemoveLRMostKeyTests.testRemoveLRMostKey(RemoveLRMostKeyTests.java:86)<br>...<br></div></div><br><br>there are 2 more failing tests</td></tr><tr class=""><td class="" id="cell-156"><span class="badge">28</span> Die Methode <code>removeRightMostKey</code> funktioniert korrekt, wenn der Knoten kein Blattknoten ist und der zugehörige Blattknoten mehr als die Mindestanzahl an Schlüsselwerten besitzt.</td><td class="" id="cell-157">[0, 1]</td><td class="table-danger" id="cell-158">0</td><td class="" id="cell-159"><nobr><i>removeRightMostKey should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.rotateFromRightSibling()</i></nobr> {<div class="pl-4">tree = {{"A","B","C","D"},"E",{"F","G","H","I"}},<br>degree = 3,<br>expected tree = {{"A","B","C","D"},"E",{"F","G","H"}}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.removeRightMostKey(BtrfsFile.java:490)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.RemoveLRMostKeyTests.callRemoveRightMostKey(RemoveLRMostKeyTests.java:111)<br>	p2.RemoveLRMostKeyTests.lambda$testRemoveLRMostKey$0(RemoveLRMostKeyTests.java:86)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfObject.run(BasicTestOfObject.java:31)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.callObject(Assertions2.java:274)<br>	p2.RemoveLRMostKeyTests.testRemoveLRMostKey(RemoveLRMostKeyTests.java:86)<br>...<br></div></div><br><br>there are 2 more failing tests</td></tr><tr class=""><td class="" id="cell-160"><span class="badge">29</span> Die Methode <code>removeRightMostKey</code> funktioniert korrekt, wenn der Knoten kein Blattknoten ist und der zugehörige Blattknoten die Mindestanzahl an Schlüsselwerten besitzt.</td><td class="" id="cell-161">[0, 1]</td><td class="table-danger" id="cell-162">0</td><td class="" id="cell-163"><nobr><i>removeRightMostKey should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.rotateFromRightSibling()</i></nobr> {<div class="pl-4">tree = {{"A","B","C","D"},"E",{"F","G"}},<br>degree = 3,<br>expected tree = {{"A","B","C"},"D",{"E","F"}}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.UnsupportedOperationException: Not implemented yet<br><div class="pl-4">	p2.btrfs.BtrfsFile.removeRightMostKey(BtrfsFile.java:490)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.RemoveLRMostKeyTests.callRemoveRightMostKey(RemoveLRMostKeyTests.java:111)<br>	p2.RemoveLRMostKeyTests.lambda$testRemoveLRMostKey$0(RemoveLRMostKeyTests.java:86)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfObject.run(BasicTestOfObject.java:31)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.callObject(Assertions2.java:274)<br>	p2.RemoveLRMostKeyTests.testRemoveLRMostKey(RemoveLRMostKeyTests.java:86)<br>...<br></div></div><br><br>there are 2 more failing tests</td></tr><tr class=""><td class="" id="cell-164"><span class="badge">30</span> Die Methode <code>removeLeftMostKey</code> funktioniert korrekt.</td><td class="" id="cell-165">[0, 1]</td><td class="table-danger" id="cell-166">0</td><td class="" id="cell-167"><nobr><i>callRemoveLeftMostKey should not throw an exception</i></nobr><wbr><nobr><i> @ BtrfsFile.rotateFromRightSibling()</i></nobr> {<div class="pl-4">tree = {"A","B","C","D","E"},<br>degree = 3,<br>expected tree = {"B","C","D","E"}</div>}<br><br><div class="alert alert-danger" role="alert">java.lang.NullPointerException: Cannot invoke "p2.btrfs.BtrfsNode.isLeaf()" because "&lt;parameter1&gt;.node.children[0]" is null<br><div class="pl-4">	p2.btrfs.BtrfsFile.removeLeftMostKey(BtrfsFile.java:502)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)<br>	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>	java.base/java.lang.reflect.Method.invoke(Method.java:568)<br>	p2.RemoveLRMostKeyTests.callRemoveLeftMostKey(RemoveLRMostKeyTests.java:126)<br>	p2.RemoveLRMostKeyTests.lambda$testRemoveLRMostKey$2(RemoveLRMostKeyTests.java:93)<br>	org.tudalgo.algoutils.tutor.general.assertions.basic.BasicTestOfObject.run(BasicTestOfObject.java:31)<br>	org.tudalgo.algoutils.tutor.general.assertions.Assertions2.callObject(Assertions2.java:274)<br>	p2.RemoveLRMostKeyTests.testRemoveLRMostKey(RemoveLRMostKeyTests.java:93)<br>...<br></div></div><br><br>there are 8 more failing tests</td></tr><tr class=""><th scope="col" class="" id="cell-168">Gesamt</th><th scope="col" class="" id="cell-169">[0, 30]</th><th scope="col" class="" id="cell-170">[4, 11]</th><th scope="col" class="" id="cell-171"></th></tr></tbody></table></div></body></html>